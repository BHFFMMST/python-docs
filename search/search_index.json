{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Uvod","text":"<p>MMST Python kurs je online radionica namijenjena za dvije ciljane skupine: </p> <ul> <li>polaznici bez predznanja (osnovni koncepti)</li> <li>polaznici sa predznanjem (napredni koncepti)</li> </ul> <p>Prva ciljanja skupina su naj\u010de\u0161\u0107e srednjo\u0161kolci ili studenti nesoftverskih fakulteta, dok je druga skupina ili polaznici prvog nivoa ili srednjo\u0161kolci i studenti IT smjerova. Sama dokumentacija se mo\u017ee koristiti i kao vodi\u010d predava\u010dima i kao primarni materijali za polaznike.</p> <p>Preporuke za sljede\u0107e korake unaprije\u0111enja:</p> <ul> <li>data science nivo - specifi\u010dna i ciljana radionica gdje se jedino konkretno primjenjuje python</li> </ul>"},{"location":"#bhff-mobile-makerspace-team","title":"BHFF Mobile Makerspace Team","text":"<p>MMST tim je jedan od mnogih timova unutar BHFF-a. Primarno smo zadu\u017eeni za dvije stvari:</p> <ul> <li>preno\u0161enje direktnog tehni\u010dkog znanja sa BHFF scholara na studente i \u0161kolarce \u0161irom BiH</li> <li>primarni outreach fondacije gdje se kroz na\u0161e radionice novi ljudi upoznavaju sa benefitima fondacije</li> </ul>"},{"location":"#test-code-snippet","title":"Test code snippet","text":"test.py<pre><code>def test():\n    print(\"Hello world!\")\n</code></pre>"},{"location":"content/basics/","title":"Osnovni koncepti","text":""},{"location":"content/basics/#cilj","title":"Cilj","text":"<p>Osnovni koncepti python radionica je kreirana sa ciljem da osobe bez ili sa veoma malo predznanja upozna sa osnovnim konceptima programiranja. Nakon radionice o\u010dekivano je da polaznici savladaju osnovne koncepte, \u0161to im daje mogu\u0107nost daljeg u\u010denja i samostalnog rada, te mo\u017eda i jo\u0161 bitnije, da otkriju da li je programiranje ba\u0161 za njih.  Jezik odabira je python radi svoje intuitivnosti i lako\u0107e brzog savladavanja gdje sami jezik ne\u0107e biti blokada u savladavanju programerskih koncepta.</p>"},{"location":"content/basics/#uslovi","title":"Uslovi","text":"<p>Radno okru\u017eenje</p>"},{"location":"content/basics/#literatura-i-dodatni-materijali","title":"Literatura i dodatni materijali","text":"<p>Dodatni materijali</p>"},{"location":"content/basics/resources/","title":"Dodatni materijali i reference","text":""},{"location":"content/basics/setup/","title":"Pode\u0161avanje okru\u017eenja","text":""},{"location":"content/basics/setup/#instalacija-za-windows","title":"Instalacija za Windows","text":""},{"location":"content/basics/setup/#instalacija-python-310-za-windows","title":"Instalacija Python 3.10 za Windows:","text":"<ol> <li> <p>Posjetiti https://www.python.org/downloads/release/python-31011/ i na dnu stranice preuzeti preporu\u010deni instalacijski program za Python 3.10.11 za Windows (Napomena: izabrati 32-bitnu ili 64-bitnu arhitekturu prema potrebi; u ostalim koracima \u0107emo pretpostaviti da je izabrana 64-bitna verzija)</p> </li> <li> <p>Po preuzimanju, pokrenuti python-3.10.11-amd64.exe i ozna\u010diti opciju Add Python 3.10 to PATH i zatim kliknuti na Install now</p> </li> <li> <p>Testiranje instalacije:</p> </li> <li>Prona\u0107i program IDLE (Python 3.10 64-bit) i pokrenuti ga</li> <li>U IDLE konzoli unesite <code>print(\"Pozdrav!\")</code> i pritisnite ENTER</li> <li>Unesite <code>exit()</code> za zatvaranje IDLE Python konzole</li> <li>Otvori terminal</li> <li>Unesite <code>python</code> i pritisnite ENTER</li> <li>Unesite <code>print(\"Pozdrav!\")</code> i pritisnite ENTER</li> <li>Unesite <code>exit()</code> za izlazak iz Python-a</li> <li>Unesite <code>exit</code> i pritisnite ENTER za zatvaranje terminala</li> </ol>"},{"location":"content/basics/setup/#instalacija-visual-studio-code-vs-code-za-windows","title":"Instalacija Visual Studio Code (VS Code) za Windows:","text":"<ol> <li>Posjetiti https://code.visualstudio.com/download i preuzmite odgovaraju\u0107i instalacijski program za VS Code za Windows</li> <li>Pokrenite preuzeti fajl VSCodeUserSetup-x64-1.83.1.exe i pratite uputstva za instalaciju</li> </ol>"},{"location":"content/basics/setup/#instalacija-za-ubuntudebian","title":"Instalacija za Ubuntu/Debian","text":"<ul> <li>Python je ve\u0107 instaliran na ve\u0107ini Linux distribucija, bitno je da je instalirana bilo koja verzija Python 3</li> <li>Za instalaciju VS Code-a posjetite https://code.visualstudio.com/docs/setup/linux i pratite uputstva za instalaciju</li> </ul>"},{"location":"content/basics/If-else%20naredba/","title":"Grananje","text":"<p>Programski kod se u ranijim poglavljima izvr\u0161avao naredbu po naredbu(linearno programiranje), te se naredba koja koja se izvr\u0161ava ne zavisi striktono od ranijeg izvr\u0161enog koda. Mnogi problemi  zahtijevaju dva ili vi\u0161e ishoda, u zavisnosti od odre\u0111enih uslova. Grananje predstavlja promjenu toka izvr\u0161avanja programa i  omogu\u0107avanje specifi\u010dnijeg reagovanja programa u zavisnosti  od ispunjenje uslova</p>"},{"location":"content/basics/If-else%20naredba/#if","title":"If","text":"<p>If naredba je osnovna kontrolna struktura u programiranju koja omogu\u0107ava izvr\u0161avanje odre\u0111enih  blokova koda samo ako se odre\u0111eni uslov ili izraz ima ta\u010dnu(istinitu) vrijednost.</p> <p>Koristi se za upravljnje tokom izvr\u0161avanja programa na osnovu trenutnih uslova. U su\u0161tini, if  naredba omogu\u0107ava programu da donosi odluke i izvr\u0161ava odre\u0111ene djilove koda samo ako su ispunjeni odre\u0111eni uslovi. </p> <p>Dijagram toka if naredbe izgleada ovako: <pre><code>graph TD\n    Start[Start] --&gt; Condition{Uslov}\n    Condition -- Uslov ispunjen --&gt; Action1[Naredbe]\n    Condition -- Ulsov nije ispunjen --&gt;End\n    Action1 --&gt; End[End]\n</code></pre></p> <p>If naredba se pi\u0161e ovako: <pre><code>if uslov:\n    blok_naredbi\n</code></pre></p> <p>Za razliku od drugih programskih jezika koji koriste viti\u010daste zagrade { } za odvajanje posebnih dijelva koda, Python koristi indentacije(1 tab) </p> <p>Uslovi u  if naredbi mogu osnovni matemati\u010dki operatori kao \u0161to su jednako (==), razli\u010dito (!=), manje (&lt;), ve\u0107e (&gt;) i modul operator (%) <pre><code>if  10 &gt; 5:\n    print(\" 10 je ve\u0107e od 5\")\n</code></pre></p>"},{"location":"content/basics/If-else%20naredba/#else","title":"Else","text":"<p>If naredba omogu\u0107ava provjeru uslova i izvr\u0161avanje bloka koda, ako je uslov ta\u010dan.</p> <p>Else se koristi za izvr\u0161avanje bloka koda kada uslov nije ta\u010dan.</p> <pre><code>graph TD\n    Start[Start] --&gt; Condition{Uslov}\n    Condition -- Uslov ispunjen --&gt; Action1[Naredbe1]\n    Condition -- Ulsov nije ispunjen --&gt;Action2[Naredba2]\n    Action1 --&gt; End[End]\n    Action2 --&gt; End[End]\n</code></pre> <pre><code>if uslov:\n    blok_naredbi_1\nelse:\n    blok_naredba_2\n</code></pre> <p>Svaka if naredba mo\u017ee da ima samo jednu else naredbu. <pre><code>if x % 2 == 0:\n    print(\"Broj je paran\")\nelse:\n    print(\"Broj je neparan\")\n</code></pre></p>"},{"location":"content/basics/If-else%20naredba/#elif","title":"Elif","text":"<p>Mnogi problemi zahtijevaju za ispitivanjem vi\u0161estruikh uslova, standardna struktura odluke if-else ne zadovoljava. \u0160to za\u010dni da ako bi smo \u017eeljeli ispitati vi\u0161e uvijeta na standardni na\u010din if-else uvjetovanjem, morali bi smo ugnijezditi vi\u0161e if-else uvijeta. To bi u\u010dinilo kod vrlo ne\u010ditljivim i te\u0161kim za razumijeti i napisati.</p> <p>Standardna if-else naredba se nadopunjuje sa elif naredbom</p> <p>Elif (kratko za else if) pravi kod kra\u0107im, \u010ditljivijim i lak\u0161im za razumijeti. </p> <pre><code>graph TD\n    Start[Start] --&gt; Condition1{Uslov1}\n    Condition1 -- Uslov1 ispunjen --&gt; Action1[Naredbe1]\n    Condition1 -- Uslov1 nije  ispunjen --&gt; Condition2{Uslov2}\n    Condition2 -- Uslov2 ispunjen --&gt; Action2[Naredbe2]\n    Condition2 -- Uslov2 nije ispunjen --&gt; Action3[Naredbe3]\n    Action1 --&gt; End[End]\n    Action2 --&gt; End\n    Action3 --&gt; End</code></pre> <pre><code>if uslov1:\n    blok_naredbi_1\nelif uslov2:\n    blok_naredba_2\nelif uslov3:\n    blok_naredbi_3\n...\nelse:\n    naredba_n\n</code></pre> <p>Za razliku od else naredbe, elif naredba se mo\u017ee koristi vi\u0161e puta za jednu if naredbu Mo\u017ee se razumijeti kao \"Ako if nije ispunjen onda ispitaj ovo...\" <pre><code>if a &gt; b:\n    print(\"Broj\",a,\"je ve\u0107i\")\nelif a &lt; b:\n    print(\"Broj\",b,\"je ve\u0107i\")\nelse:\n    print(\"Brojevi su jedanki\")\n</code></pre></p>"},{"location":"content/basics/If-else%20naredba/#logicki-operatori","title":"Logi\u010dki operatori","text":"<p>\u010cesto se de\u0161ava da problem koji se rje\u0161ava zahtjeva da se vi\u0161e uslova provjeri od jednom if bloku. Tada se koriste logi\u010dki operatori.</p> <p>Logi\u010dki operatori su and (i), or (ili) i nor (ne).</p> <p>Kada je potrebno navesti vi\u0161e uslova i pri tome da SVI USLOVI MORAJU BITI ISPUNJENI korisit se and operator. <pre><code>if (ocjena &gt;= 85 and ocjena &lt;= 100):\n    print(\"Ocjena je 5\")\n</code></pre></p> <p>Kada je potrebno navesti vi\u0161e uslova i pri tome da BAR JEDAN USLOV MORA BITI ISPUNJEN korisit se or operator.</p> <pre><code>if (x &lt; 0 or  x &gt; 100):\n    print(\"Nevalidan unos\")\n</code></pre> <p>Kada je potrebno da navedeni uslov NIJE ISPUNJEN onda se koristi not operator.</p> <pre><code>if (not x % 2 == 0):\n    print(\"Broje je neparan\")\n</code></pre> <p>Operatori pore\u0111enja imaju ve\u0107i prioritet od logi\u010dkih operatora, tj. operatori pore\u0111enja \u0107e se izvr\u0161iti prvi, pa tek ondalogi\u010dki operatori.</p>"},{"location":"content/basics/Nizovi/","title":"Nizovi","text":"<p>\u010cesto se javljaju problemi koji zahtijevaju veliki broj podataka. Kada bi za svaku od njih koristili posebne varijable, imali bi smo veliki broj varijabli. To bi dosta ote\u017ealo rad i \u010ditljivost koda. U takvim situacijama se koriste nizovi.</p> <p>Niz je slo\u017eena promjeniva koja se koritsti za pohranu vi\u0161eg broja istih varijabli. Postoje jednodimenzonalni i vi\u0161edimenzionalni nizovi.</p> <pre><code>import array\n\nime_varijble = array(tip_podatka,[elementi])\n</code></pre> <p>Da bi se radilo sa nizovima potrebno je uklju\u010diti array modul. Elementi niz se pi\u0161u unutar srednih zagrada i odvajaju se zarezom. Svaka element  u nizu ima svoj redni broj(indeks), pomo\u0107u koje se mo\u017ee pristupati tom elementu. Indeksi po\u010dinju sa brojem 0. Tip podatak govori koja vrsta podataka se nalazi unutar niza.</p> <p>\"i\" se korisiti za tip podataka int. \"f\" za float.</p> <pre><code>import array as arr\n\nniz = arr.array('i',[1, 2, 3, 4, 5])\nprint(niz[0])\nprint(niz[1])\nprint(niz[4])\n</code></pre> <pre><code>Output: 1\n        2\n        5\n</code></pre> <p>Niz se mo\u017ee mijenati i dozvoljava duplikate.</p> <p>Funkcija append() dodaje na kraj niza samo jedan elemenat.</p> <p>Funkcija extend() dodaje na kraj niza vi\u0161e elemenata.</p> <pre><code>import array as arr\n\nniz = arr.array('i',[1, 2, 3, 4, 5])\nniz[3] = 6\nniz.append(7)\nniz.extend([8, 8, 10])\nprint(niz)\n</code></pre> <pre><code>Output: array('i', [1, 2, 3, 6, 5, 7, 8, 8, 10])\n</code></pre> <p>Za printanje samo elemenata niza koristi se for petlja</p> <pre><code>import array as arr\n\nniz = arr.array('i',[1, 2, 3, 4, 5])\n\nfor i in niz:\n    print(i)\n</code></pre> <pre><code>Output: 1\n        2\n        3\n        4\n        5\n</code></pre> <p>Za dodavanje elemenata u niz na odre\u0111eno mjesto, umijesto na kraj, koristi se funkcija insert().</p> <p>Za izbacivanje elemenata iz niza koristi se funkcija remove().</p> <p>Funkcija remove \u0107e izbaciti prvi element koji ima vrijednost koja joj se proslijedi, ukoliko imamo vi\u0161e  elemenata iste vrijednosti.</p> <p>Za izbacivanje elemenata na odre\u0111enoj poziciji koristi se funkcija pop()</p> <pre><code>import array as arr\n\nniz = arr.array('i',[1, 2, 3, 4, 5])\nniz.insert(0, 2)\nniz.remove(3)\nniz.pop(3)\n\nfor i in niz:\n    print(i)\n</code></pre> <pre><code>Output: 2\n        1\n        5\n</code></pre>"},{"location":"content/basics/Nizovi/#visedimenzionalni-niz","title":"Vi\u0161edimenzionalni niz","text":"<pre><code>import numpy as np\n\nniz = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\nprint(niz)\n</code></pre> <pre><code>Output: array([[ 1,  2,  3,  4],\n               [ 5,  6,  7,  8],\n               [ 9, 10, 11, 12]])\n</code></pre>"},{"location":"content/basics/Nizovi/#liste","title":"Liste","text":"<p>Liste su naj\u010de\u0161\u0107e kori\u0161teni  tip podataka za pohranu vi\u0161eg broja podataka.</p> <p>Lista je slo\u017eena promjeniva koja se koristi za pohranu vi\u0161eg broja varijabli.</p> <p>Liste i nizovi su sli\u010dni. Ali za razliku od nizova, liste mogu u sebi sadr\u017eati razli\u010dite vrte varijabli.</p> <pre><code>lista = [\"Hello\", \"world\", \"!\"]\n</code></pre> <p>Elementi liste se pi\u0161u unutar srednih zagrada i odvajaju se zarezom.</p> <p>Svaka element  u listi ima svoj redni broj (indeks), pomo\u0107u koje se mo\u017ee pristupati tom elementu.</p> <p>Indeksi po\u010dinju sa brojem 0.</p> <pre><code>broj = 3\nlista = [\"Hello\", 0, [1, 2, 3], broj, 4.5]\nprint(lista[0])\nprint(lista[2])\nprint(lista[2][1])\n</code></pre> <pre><code>Output: Hello\n        [1, 2, 3]\n        2\n</code></pre> <p>Tip podatka kao \u0161to je string, mo\u017ee bit indeksiran. Indeksira se kao lista koja sadr\u017ei znakove u stringu.</p> <pre><code>string = \"Hello world\"\nprint(string[6])\n</code></pre> <pre><code>Output: w       \n</code></pre> <p>Liste se mogu sabirati i mno\u017eiti na isti na\u010din kao i stringovi.</p> <pre><code>lista = [1, 2, 3]\nprint(lista + [4, 5, 6])\npritn(lista * 2)\n</code></pre> <pre><code>Output: [1, 2, 3, 4, 5, 6]\n        [1, 2, 3, 1, 2, 3]       \n</code></pre> <p>Za provjeru da li se element nalazi u listi, koristi se in operator.</p> <pre><code>lista = [\"pas\", \"macka\", \"patka\"]\nprint(\"pas\" in lista)\npritn(\"krava\" in lista)\n</code></pre> <pre><code>Output: True\n        False      \n</code></pre> <p>Liste se mogu mjenati i koriste se funkcije kao \u0161to su append(), insert(), remove(), pop().</p> <pre><code>lista = [1, 2, 3]\nlista.append(4)\nlista.insert(0, 0)\nlista.remove(2)\nlista.pop(1)\nprint(lista)\n</code></pre> <pre><code>Output: [0, 3, 4]           \n</code></pre> <p>Za broj elemenata liste korsiti se funkcija len()</p> <pre><code>lista = [1, 2, 3]\nprint(len(lista))\n</code></pre> <pre><code>Output: 3           \n</code></pre> <p>Za sortiranje liste korisit se funkcija sort().</p> <pre><code>lista1= [74, 98, 125, 34, 172]\nlista2 = [\"mango\", \"jabuka\", \"banana\", \"kivi\"]\nlista1.sort()\nlista2.sort()\nprint(lista1)\nprint(lista2)\n</code></pre> <pre><code>Output: [34,74, 98, 125, 172]\n        [\"banana\", \"jabuka\", \"kivi\", \"mango\"]           \n</code></pre>"},{"location":"content/basics/Petlje/","title":"Petlje","text":"<p>Petlje su programske strukture koje omogu\u0107avaju vi\u0161estruko ponavljanje  odre\u0111enog dijela koda (bloka koda).</p> <p>Kao i if-else naredbe, petlje sadr\u017ee uslov. Ukoliko je uslov ispunjen blok koda se ponavlja odre\u0111eni broj puta, sve dok se uslov postane neta\u010dan.</p> <p><pre><code>graph TD\n    Start[Start] --&gt; Condition{Uslov}\n    Condition -- Ta\u010dno --&gt; Action1[Naredba]\n    Condition -- Neta\u010dno --&gt; End[End]\n    Action1 --&gt; Condition{Uslov}\n</code></pre> Postoje  dvije vrste petlji:</p> <ul> <li>petlje kontrolisane broja\u010dem (for petlje)</li> <li>petlje kontrolisane uslovom (while petlje)</li> </ul>"},{"location":"content/basics/Petlje/#for-petlja","title":"For petlja","text":"<p>For petlja se korisiti u situcijama u kojima se unaprijed odre\u0111en broj ponavljana petlje.</p> <p>Ona je broja\u010dka petlja. <pre><code>for i in range(a, b, k):\n    blok_naredbi\n</code></pre></p> <p>Za prolazak kroz niz cijelih brojeva koristi se range funkcija</p> <ul> <li>a - po\u010detna vrijednost petlje (broja\u010da)</li> <li>b - krajnja vriednost petlje (broja\u010da)</li> <li>k - korak petlje (broja\u010da). 1 po defaultu.</li> </ul> <pre><code>for i in range(1, 6):\n    print(i)\n</code></pre> <pre><code>Output: 1\n        2\n        3\n        4\n        5\n</code></pre>"},{"location":"content/basics/Petlje/#while-petlja","title":"While petlja","text":"<p>While petlja omogu\u0107ava ponavljanje kada je odre\u0111eni uslov ispunjen.</p> <p>Korisi se kada ne znamo ta\u010da broj ponavljanja. Ova petlja je uslovna petlja. <pre><code>while uslov:\n    blok_naredbi\n</code></pre></p> <pre><code>i = 1\nwhile i &lt;= 5:\n    print(i)\n</code></pre> <pre><code>Output: 1\n        2\n        3\n        4\n        5\n</code></pre> <p>Podlo\u017ena je logi\u010dkim gre\u0161kama (beskona\u010dna petlja). Zbog toga se koriste funkcije break i continue</p> <p>Funkcija break se koristi za izlaz iz petlje.</p> <pre><code>i = 1\nwhile i &lt;= 5:\n    if i == 3:\n        brak\n    print(i)\n</code></pre> <pre><code>Output: 1\n        2\n        3\n</code></pre> <p>Funkcija continue se koristi za preskakanje iteracije. Odnosno, zaustavlja trenutnu iteraciju i nastavlja sa sljede\u0107om.</p> <pre><code>i = 1\nwhile i &lt;= 5:\n    if i == 3:\n        continue\n    print(i)\n</code></pre> <pre><code>Output: 1\n        2\n        4\n        5\n</code></pre>"},{"location":"content/basics/Petlje/#ugnjezdene-petlje","title":"Ugnje\u017edene petlje","text":"<p>Ugnje\u017edene petlje prestavljaju petlju unutar petlje.</p> <p>Kada se petlja nalazi unutar druge petlje, za svaku iteraciju vanjske petlje unutarnja petlja mora pro\u0107i kroz sve svoje iteracije.</p> <pre><code>for i in range(a, b, k):\n    for j in range(c, d, e):\n        blok_naredbi_2\n    blok_naredbi_1\n</code></pre> <pre><code>for i in range(0, 5):\n    for j in range(0, i + 1):\n        print(\"*\", end=' ')\n    print()\n</code></pre> <pre><code>Output: *\n        * *\n        * * *\n        * * * *\n        * * * * *\n</code></pre>"},{"location":"content/basics/funkcije/","title":"Funkcije","text":"<p>Funkcije predstavljaju imenovane blokove koda koji su namijenjeni za izvr\u0161avanje odre\u0111enih zadataka, a mogu se pozivati iz drugih dijelova programa. Jednom napisana funkcija se mo\u017ee pozivati vi\u0161e puta, \u0161to je i njena svrha, na taj na\u010din se izbjegava ponavljanje istog koda vi\u0161e puta.</p>"},{"location":"content/basics/funkcije/#definisanje-funkcije","title":"Definisanje funkcije","text":"<p>U nastavku je primjer definisanja funkcije koja ispisuje pozdravnu poruku:</p> <pre><code>def print_pozdrav():\n    print(\"Pozdrav!\")\n\nprint_pozdrav()\n</code></pre> <p>Ovaj primjer pokazuje najjednostavniju strukturu funkcije. Klju\u010dna rije\u010d <code>def</code> ozna\u010dava po\u010detak definicije funkcije, nakon koje slijedi ime funkcije, u ovom slu\u010daju je to <code>print_pozdrav</code>, zatim se navode zagrade u kojima se mogu navesti parametri funkcije. U ovom slu\u010daju funkcija nema parametre, pa su zagrade prazne, i one su obavezne, bez obzira da li funkcija ima ili nema parametre, a nako toga slijedi dvota\u010dka. </p> <p>Sve naredbe koje pripadaju funkciji moraju da se nalaze u bloku koda koji je uvu\u010den u odnosu na definiciju funkcije. U ovom slu\u010daju je to samo jedna naredba, ali ih mo\u017ee biti vi\u0161e.</p> <p>Kada smo definisali funkciju, mo\u017eemo je pozvati u bilo kojem dijelu programa i to na na\u010din da navedemo ime funkcije, pra\u0107eno zagradama u kojima se navode argumenti koje proslje\u0111ujemo funkciji. To se naziva poziv funkcije. U ovom slu\u010daju funkcija nema parametre, pa su zagrade prazne.</p>"},{"location":"content/basics/funkcije/#parametri-funkcije","title":"Parametri funkcije","text":"<p>Funkcija mo\u017ee imati jedan ili vi\u0161e parametara, a oni se navode u zagradama prilikom definisanja funkcije. Parametri su promjenljive koje se koriste unutar funkcije i njihove vrijednosti se proslje\u0111uju prilikom poziva funkcije. U nastavku je primjer funkcije koja ispisuje pozdravnu poruku za proslje\u0111eno ime:</p> <pre><code>def print_pozdrav(ime):\n    print(f\"Pozdrav {ime}!\")\n\nprint_pozdrav(\"BHFF\")\n</code></pre> <p>U ovom slu\u010daju funkcija ima jedan parametar, a to je <code>ime</code>. Funkcija sada o\u010dekuje da se prilikom poziva proslijedi jedan argument, koji \u0107e se dodjeliti parametru <code>ime</code> u funkciji. U ovom slu\u010daju je to string <code>\"BHFF\"</code>.</p> <p>Razlika izme\u0111u parametara i argumenata?</p> <p>Parametri su promjenljive koje se navode prilikom definisanja funkcije, a argumenti su vrijednosti koje se proslje\u0111uju prilikom poziva funkcije. U prethodnom primjeru, argument je <code>\"BHFF\"</code> koji je proslje\u0111en funkciji <code>print_pozdrav</code>, a vrijednost tog argumenta je dodjeljena parametru <code>ime</code> u funkciji. </p> <p>Napomena: Nerijetko se ova dva pojma koriste naizmjeni\u010dno, ali je va\u017eno razumjeti razliku izme\u0111u njih.</p>"},{"location":"content/basics/funkcije/#prosljeivanje-argumenata-funkciji","title":"Proslje\u0111ivanje argumenata funkciji","text":"<p>U prethodnom primjeru smo naveli funkciju sa jednim parametrom, ali kako smo ve\u0107 ranije naveli, funkcija mo\u017ee imati vi\u0161e parametara. Kada funkcija ima vi\u0161e parametara, o\u010dekivano je da se prilikom poziva funkcije proslijedi isti broj argumenata. proslje\u0111ivanje argumenata funkciji se mo\u017ee uraditi na dva na\u010dina, koriste\u0107i poziciju - pozicioni argumenti ili koriste\u0107i klju\u010dnu rije\u010d parametra - klju\u010dni argumenti. </p>"},{"location":"content/basics/funkcije/#pozicioni-argumenti-positional-arguments","title":"Pozicioni argumenti (positional arguments)","text":"<p>Prilikom poziva funkcije, Python mora da zna koji argument se proslje\u0111uje kojem parametru, a to se u ovom slu\u010daju odre\u0111uje na osnovu redoslijeda navo\u0111enja argumenata. U nastavku je primjer funkcije koja ispisuje informaciju o ljubimcu:</p> <pre><code>def opisi_ljubimca(ime_ljubimca, vrsta_ljubimca):\n    print(f\"Moj ku\u0107ni ljubimac je {vrsta_ljubimca}, a zove se {ime_ljubimca}.\")\n\nopisi_ljubimca(\"Leksi\", \"pas\")\n</code></pre> <p>U ovom slu\u010daju funkcija ima dva parametra, <code>ime_ljubimca</code> i <code>vrsta_ljubimca</code>. Kada pozivamo ovu funkciju, potrebno je da argumente proslijedimo u istom redoslijedu kao \u0161to su navedeni parametri. U ovom slu\u010daju, prvi argument je <code>\"Leksi\"</code> i on se proslje\u0111uje prvom parametru <code>ime_ljubimca</code>, a drugi argument je <code>\"pas\"</code> i on se proslje\u0111uje drugom parametru <code>vrsta_ljubimca</code>.</p> <p>Napomena: Ukoliko se argumenti ne proslijede u istom redoslijedu kao \u0161to su navedeni parametri, mo\u017ee do\u0107i do neo\u010dekivanog rezultata.</p>"},{"location":"content/basics/funkcije/#kljucni-argumenti-keyword-arguments","title":"Klju\u010dni argumenti (keyword arguments)","text":"<p>Klju\u010dni argumenti se koriste kada \u017eelimo da proslijedimo argumente funkciji na osnovu imena parametra, a ne na osnovu pozicije. U nastavku je prethodni primjer koji koristi klju\u010dne argumente u pozivu funkcije:</p> <pre><code>def opisi_ljubimca(ime_ljubimca, vrsta_ljubimca):\n    print(f\"Moj ku\u0107ni ljubimac je {vrsta_ljubimca}, a zove se {ime_ljubimca}.\")\n\nopisi_ljubimca(vrsta_ljubimca=\"pas\", ime_ljubimca=\"Leksi\")\n</code></pre> <p>U ovom slu\u010daju, prvo navodimo ime parametra, a zatim vrijednost koju \u017eelimo da proslijedimo. Na ovaj na\u010din, redoslijed argumenata nije bitan, jer se argumenti proslje\u0111uju na osnovu imena parametra, prema tome, mo\u017eemo i ovako pozvati funkciju:</p> <pre><code>opisi_ljubimca(ime_ljubimca=\"Leksi\", vrsta_ljubimca=\"pas\")\n</code></pre> <p>Napomena: Mogu\u0107e je kombinovati pozicione i klju\u010dne argumente, ali je va\u017eno da se prvo navedu pozicioni argumenti, a zatim klju\u010dni argumenti.</p>"},{"location":"content/basics/funkcije/#proizvoljan-broj-argumenata","title":"Proizvoljan broj argumenata","text":"<p>Funkcija mo\u017ee imati proizvoljan broj argumenata, a to se posti\u017ee tako \u0161to se parametar navodi sa prefiksom <code>*</code>. U nastavku je primjer takve funkcije:</p> <pre><code>def napuni_listu(*elementi):\n    lista = []\n\n    for element in elementi:\n        lista.append(element)\n\n    return lista\n</code></pre> <p>Ova funkcija prima proizvoljan broj argumenata, a zatim ih dodaje u listu i vra\u0107a konstruisanu listu. Kada pozivamo ovu funkciju, mo\u017eemo proslijediti proizvoljan broj argumenata:</p> <pre><code>spisak = napuni_listu(\"jabuka\", \"kru\u0161ka\", \"\u0161ljiva\")\nprint(spisak)\n</code></pre>"},{"location":"content/basics/funkcije/#predefinisane-vrijednosti-parametara","title":"Predefinisane vrijednosti parametara","text":"<p>Kada pi\u0161emo funkciju, mo\u017eemo navesti predefinisanu (zadanu) vrijednosti (default value) parametara. Ako se prilikom poziva funkcije ne proslijedi argument za taj parametar, funkcija \u0107e koristiti predefinisanu vrijednost, a ako se proslijedi argument, funkcija \u0107e koristiti vrijednost koja je proslje\u0111ena. U nastavku je primjer funkcije koja ispisuje informaciju o ljubimcu, ali ovaj put sa predefinisanim parametrom <code>vrsta_ljubimca</code>:</p> <pre><code>def opisi_ljubimca(ime_ljubimca, vrsta_ljubimca=\"pas\"):\n    print(f\"Moj ku\u0107ni ljubimac je {vrsta_ljubimca}, a zove se {ime_ljubimca}.\")\n\nopisi_ljubimca(ime_ljubimca=\"Leksi\")\n</code></pre> <p>U ovom slu\u010daju, funkcija ima predefinisani parametar <code>vrsta_ljubimca</code> koji ima vrijednost <code>\"pas\"</code>. Kada pozivamo funkciju, mo\u017eemo proslijediti argument za taj parametar, ali to nije obavezno, jer \u0107e funkcija koristiti predefinisanu vrijednost. </p> <p>Za opis nekog drugog ljubimca, mo\u017eemo proslijediti argument za taj parametar:</p> <pre><code>opisi_ljubimca(ime_ljubimca=\"\u010cupka\", vrsta_ljubimca=\"ma\u010dka\")\n</code></pre> <p>Napomena: Parametri sa predefinisanom vrijedno\u0161\u0107u moraju biti navedeni nakon parametara bez predefinisane vrijednosti. Ovo Python-u omogu\u0107ava da na ispravan na\u010din interpretira argumente na osnovu pozicije.</p>"},{"location":"content/basics/funkcije/#opcioni-parametri","title":"Opcioni parametri","text":"<p>Ponekad ima smisla da neki parametri budu opcioni, za to se koriste predefinisane vrijednosti parametara. Posmatrajmo primjer:</p> <pre><code>def opisi_ljubimca(ime_ljubimca, vrsta_ljubimca, starost_ljubimca=None):\n    if starost_ljubimca:\n        print(f\"Moj ku\u0107ni ljubimac je {vrsta_ljubimca}, a zove se {ime_ljubimca} i ima {starost_ljubimca} godina.\")\n    else:\n        print(f\"Moj ku\u0107ni ljubimac je {vrsta_ljubimca}, a zove se {ime_ljubimca}.\")\n</code></pre> <p>Kada pozivamo funkciju, mo\u017eemo proslijediti argument za parametar <code>starost_ljubimca</code>, ali to nije obavezno, jer je taj parametar opcioni. Ukoliko se proslijedi taj argument, funkcija \u0107e ispisati vi\u0161e informacija o ljubimcu, a ako se ne proslijedi, funkcija \u0107e ispisati samo ime i vrstu ljubimca.</p> <pre><code>opisi_ljubimca(ime_ljubimca=\"Leksi\", vrsta_ljubimca=\"pas\", starost_ljubimca=3)\n\nopisi_ljubimca(ime_ljubimca=\"\u010cupka\", vrsta_ljubimca=\"ma\u010dka\")\n</code></pre>"},{"location":"content/basics/funkcije/#povratna-vrijednost-funkcije","title":"Povratna vrijednost funkcije","text":"<p>Funkcija mo\u017ee da vrati neki rezultat, a to se naziva povratna vrijednost funkcije. Klju\u010dna rije\u010d <code>return</code> ozna\u010dava povratnu vrijednost funkcije, a nakon nje se navodi vrijednost koju funkcija vra\u0107a, ta vrijednost se vra\u0107a na mjesto poziva funkcije. U nastavku je primjer jedne takve funkcije:</p> <pre><code>def kvadriraj(broj):\n    return broj * broj\n</code></pre> <p>Ova funkcija prima jedan parametar <code>broj</code>, a zatim vra\u0107a kvadrat tog broja. Kada pozivamo ovu funkciju, mo\u017eemo rezultat dodijeliti nekoj promjenljivoj:</p> <pre><code>broj = 5\nkvadrat = kvadriraj(broj)\nprint(f\"Kvadrat broja {broj} je {kvadrat}.\")\n</code></pre> <p>U ovom slu\u010daju, funkcija <code>kvadriraj</code> vra\u0107a kvadrat broja <code>5</code>, koji se dodjeljuje promjenljivoj <code>kvadrat</code>. Povratne vrijednosti omogu\u0107avaju da se klju\u010dni dijelovi koda izdvajaju u funkcije, a zatim da se rezultat tih funkcija koristi u drugim dijelovima programa, \u0161to doprinosi boljoj \u010ditljivosti i odr\u017eavanju programa jer se pojednostavljuje glavni dio programa.</p> <p>Napomena: Funkcija koja ne vra\u0107a nikakvu vrijednost, takva funkcija se naziva void funkcija i u Python-u takve funkcije zapravo vra\u0107aju <code>None</code>.</p>"},{"location":"content/basics/funkcije/#povratak-vise-vrijednosti","title":"Povratak vi\u0161e vrijednosti","text":"<p>Funkcija mo\u017ee vratiti vi\u0161e vrijednosti, a to se posti\u017ee tako \u0161to se vrijednosti odvoje zarezom. U nastavku je primjer takve funkcije:</p> <pre><code>def povrsina_i_obim_kvadrata(stranica):\n    povrsina = stranica * stranica\n    obim = 4 * stranica\n    return povrsina, obim\n</code></pre> <p>Ova funkcija prima jedan parametar <code>stranica</code>, a zatim vra\u0107a povr\u0161inu i obim kvadrata. Kada pozivamo ovu funkciju, mo\u017eemo rezultat dodijeliti dvjema promjenljivim:</p> <pre><code>stranica = 5\npovrsina, obim = povrsina_i_obim_kvadrata(stranica)\nprint(f\"Povr\u0161ina kvadrata sa stranicom {stranica} je {povrsina}, a obim je {obim}.\")\n</code></pre>"},{"location":"content/basics/operatori/","title":"Operatori","text":"<p>Operatori se koriste za izvr\u0161avanje razli\u010ditih operacija na varijablama i vrijednostima.  U prethodnom segmentu smo spomenuli operator \"=\" \u0161to je u pythonu operator dodjele, a ne matemati\u010dki operator jednako. \u0160ta to zna\u010di? Vrijednosti sa desne strane od \"=\" se dodjeljuju u varijablu sa lijeve strane \"=\".</p> <pre><code>x = 1 # 1 se dodjeljuje u x\ny = x # vrijednost od x se dodjeljuje u y, te ce y imati vrijednost 1\n</code></pre> <p>NOTE: # je znak za komentar unutar pythona. Sve iza znaka \"#\" se ignori\u0161e prilikom izvr\u0161avanja koda.</p>"},{"location":"content/basics/operatori/#matematicki-operatori","title":"Matemati\u010dki operatori","text":"<p>Za izvr\u0161enje osnovnih matemati\u010dkih operacija koristimo operatore:</p> <ul> <li>+,  sabiranje/dodavanje</li> <li>-, oduzimanje</li> <li>*, mno\u017eenje</li> <li>/, dijeljenje</li> <li>%, modul (vra\u0107a ostatak prilikom cjelobrojnog dijeljenja)</li> <li>**, eksponencijacija</li> <li>//, cjelobrojno dijeljenje</li> </ul> <pre><code>x = 1 + 2 # 3\nx = 2 - 1 # 1\nx = 2 * 2 # 4\nx = 4 / 2 # 2\nx = 12 / 2 # 0\nx = 3 ** 2 # 9\nx = 5 // 2 # 2\n</code></pre>"},{"location":"content/basics/operatori/#operatori-dodjele","title":"Operatori dodjele","text":"<p>Pored osnovnog znaka \"=\" imamo dodatne operatore dodjele:</p> <ul> <li>=, primjer: x = 5, isto kao: x = 5    </li> <li>+=, primjer: x += 3, isto kao: x = x + 3  </li> <li>-=, primjer: x -= 3, isto kao: x = x - 3  </li> <li>=, primjer: x = 3, isto kao: x = x * 3  </li> <li>/=, primjer: x /= 3, isto kao: x = x / 3  </li> <li>%=, primjer: x %= 3, isto kao: x = x % 3  </li> <li>//=, primjer: x //= 3, isto kao: x = x // 3   </li> <li>=, primjer: x = 3, isto kao: x = x ** 3</li> </ul>"},{"location":"content/basics/operatori/#operatori-komparacije","title":"Operatori komparacije","text":"<p>Operatori komparacije se koriste za pore\u0111enje dvije vrijednosti/varijable:</p> <ul> <li>==, jednako, x == y   </li> <li>!=, nije jednako, x != y  </li> <li>&gt;, ve\u0107e od, x &gt; y    </li> <li>&lt;, manje od, x &lt; y    </li> <li>&gt;=, ve\u0107e ili jednako, x &gt;= y </li> <li>&lt;=, manje ili jednako, x &lt;= y</li> </ul> <p>Navedeni operatori kao rezultat vra\u0107aju bool varijablu vrijednosti True ili False zavisno od rezultata komparacije.</p>"},{"location":"content/basics/operatori/#prioriteti-operacija","title":"Prioriteti operacija","text":"<p>Kao i u matematici, operatori unutar programskih jezika imaju razli\u010dite prioriteta tokom njihovih izvr\u0161enja. Unutar pythona, od najve\u0107eg do najni\u017eeg prioriteta:</p> <ul> <li>()    </li> <li>**</li> <li>*  /  //  %</li> <li>+  -</li> <li>==  !=  &gt;  &gt;=  &lt;  &lt;=</li> <li>not   logi\u010dko \"ne\"</li> <li>and   logi\u010dko \"i\"</li> <li>or    logi\u010dko \"ili\"</li> </ul> <p>Na logi\u010dke operatore \u0107emo se vi\u0161e osvrnuti unutar modula o if-else naredbama</p>"},{"location":"content/basics/ponavljanje/","title":"Ponavljanje","text":""},{"location":"content/basics/unos_ispis/","title":"Unos i ispis","text":"<p>U prethodnim modulima smo predstavili kako kreirati varijable i koje operacije mo\u017eemo raditi sa njima.</p>"},{"location":"content/basics/unos_ispis/#ispis","title":"Ispis","text":"<p>Da bismo ispisali rezultate operacija sa na\u0161im varijablama koristimo funkciju \"print()\" <pre><code>x = 1\nprint(x)\n</code></pre></p> <pre><code>Output: 1\n</code></pre> <p>Unutar print funkcije mo\u017eemo ispisati i vi\u0161e varijabli tako \u0161to ih odvojimo sa zarezom unutar print funkcije <pre><code>x = 1\ny = 2\nz = 3\nprint(x, y, z)\n</code></pre></p> <pre><code>Output: 1 2 3\n</code></pre> <p>Mo\u017eemo i raditi sve postoje\u0107e operacije unutar print funkcije nakon \u010dega \u0107emo kao izlaz dobiti rezultat nakon izvr\u0161enja istih <pre><code>x = 1\ny = 2\na = \"hello \"\nb = \"world\"\nprint(x + y)\nprint(a + b)\n</code></pre></p> <pre><code>Output: 3\n        hello world\n</code></pre> <p>Print funkcija ne ispisuje samo varijable, ve\u0107 i konkretne vrijednosti koje joj zadamo <pre><code>x = 1\nprint(1)\nprint(\"Vrijednost varijable x je: \", x)\n</code></pre></p> <pre><code>Output: 1\n        Vrijednost varijable x je: 1\n</code></pre>"},{"location":"content/basics/unos_ispis/#unos","title":"Unos","text":"<p>Da bismo omogu\u0107ili korisniku da unosi svoje vrijednosti u program koristimo funkciju \"input()\". <pre><code>x = input(\"Unesite cijeli broj: \")\nprint(x)\n</code></pre></p> <p>Izvr\u0161enje programa se pauzira sve dok korisnik ne unese vrijednost i pritisne enter, nakon \u010dega se ispi\u0161e vrijednost varijable.</p> <p>Znanje iz prethodnih modula mo\u017eete iskoristiti za kreiranje programa koji izvr\u0161avaju razli\u010dite matemati\u010dke zadatke. Npr. Ra\u010dunanje i ispis povr\u0161ine pravougaonika korisni\u010dki unesenih dimenzija</p>"},{"location":"content/basics/varijable/","title":"Varijable","text":"<p>Python za razliku od jezika kao \u0161to su java, C#, C++... nema komandu za \"deklarisanje\" varijable. </p> <p>Deklarisanje varijable bi unutar navedenih jezika funkcionisalo tako \u0161to biste dali tip varijable, nakon \u010dega biste naveli ime same varijable. Primjer unutar jave: <pre><code>int varijabla;\n</code></pre></p> <p>Kako onda kreiramo varijable u pythonu? Tako \u0161to im damo vrijednost. Pomo\u0107u operatora \"=\" dodjeljujemo vrijednost varijablama. Vi\u0161e o ovome operatoru unutar sekciji za operatore.</p> <p>Dakle, varijabla se kreiraju u momentu kada im damo vrijednost <pre><code>x = 1\nb = \"primjer\"\n</code></pre></p>"},{"location":"content/basics/varijable/#tipovi-varijabli","title":"Tipovi varijabli","text":"<p>\u0160ta to zna\u010di za tipove varijabli? Python ih automatski zadaje kada varijabli damo vrijednost, te \u010dak automatski mijenja tip u slu\u010daju promjene vrijednosti iste varijable. </p> <p>U primjeru iznad varijabla \"x\" \u0107e dobiti tip int, tj. integer \u0161to predstavlja cijeli broj, dok \u0107e varijabla \"y\" dobiti tip str, tj. string.</p> <p>\u0160ta ako \u017eelimo kreirati varijablu specifi\u010dnog tipa? Tada \u0107emo koristiti takozvani \"casting\" da striktno konvertujemo vrijednost u zadani tip varijable. <pre><code>x = str(1)\n</code></pre></p> <p>Generalno \"casting\" kao koncept se mo\u017ee koristiti i za konvertovanje ve\u0107 postoje\u0107e varijable u drugi tip. Razlog je naj\u010de\u0161\u0107e kori\u0161tenje brojnih vrijednosti kao string ili obrnuto.</p> <p>Osnovni tipovi varijabli koji postoje u pythonu (i ve\u0107ini ostalih programskih jezika) su:</p> <ul> <li>str - string, tekstualni tip varijable</li> <li>int - cijeli broj</li> <li>float - decimalni broj</li> <li>bool - binarni tip podatka, mo\u017ee sadr\u017eavati samo vrijednosti \"True\" i \"False\" tj. 0 ili 1</li> </ul>"},{"location":"content/basics/varijable/#brojevi","title":"Brojevi","text":"<p>Numeri\u010dki tipovi varijabli u pythonu su int i float. </p> <p>Int je cijeli broj, pozitivan ili negativan beskona\u010dne du\u017eine <pre><code>x = 1\ny = -1\nz = 125871726508610512\n</code></pre></p> <p>Float je decimalni broj, pozitivan ili negativan beskona\u010dne du\u017eine <pre><code>x = 1.0\ny = 1.5\nz = -3.41\n</code></pre></p>"},{"location":"content/basics/varijable/#stringovi","title":"Stringovi","text":"<p>Stringovi su tekstualni tip varijable.</p> <p>Stringove mo\u017eemo definisati i sa jednostrukim i dvostrukim navodnicima <pre><code>x = \"primjer\"\ny = 'primjer'\n# oba na\u010dina su validna\n</code></pre></p> <p>Tako\u0111er mo\u017eemo kreirati string od vi\u0161e linija sa trostrukim navodnicima <pre><code>x = \"\"\"Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt\nut labore et dolore magna aliqua.\"\"\"\ny = '''Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit,\nsed do eiusmod tempor incididunt\nut labore et dolore magna aliqua.'''\n# oba na\u010dina su validna\n</code></pre></p>"},{"location":"content/basics/varijable/#imenovanje-varijabli","title":"Imenovanje varijabli","text":"<p>Jedna od po\u010detni\u010dkih gre\u0161ki je lo\u0161e imenovanje varijabli. Svaki jezik ima osnovne uslove imenovanja varijabli:</p> <ul> <li>varijabla mora kao prvi karakter imati ili slovo ili donju crtu</li> <li>varijabla ne smije imati razmak unutar imena</li> <li>...</li> </ul> <pre><code>2x = 1 # nije validno ime\nx = 1 # validno ime\n</code></pre> <p>Navedeni uslovi reguli\u0161u da su imena varijabli validna, ali ne i dobra. Ime same varijable treba biti deskriptivno, jednostavno i jasno, da u kasnijem kori\u0161tenju varijable se mo\u017ee na osnovu imena zaklju\u010diti \u0161ta ona predstavlja.</p> <p>Uzet \u0107emo primjer da \u017eelimo kreirati varijablu koja predstavlja ime korisnika <pre><code>x = \"Ahmed\" # nedeskriptivno ime, gdje se iz imena ne moze zakljuciti sta ona predstavlja\nimeKorisnika = \"Ahmed\" #deskriptivno ime varijable\n</code></pre></p> <p>Postoji vi\u0161e na\u010dina kako se pravilno pi\u0161u imena varijabli koja sadr\u017ee vi\u0161e rije\u010di unutar sebe, od kojih naj\u010de\u0161\u0107i u upotrebi su:</p> <ul> <li>camel case: prva rije\u010d po\u010dinje sa malim slovom, dok svaka sljede\u0107a velikim (imeKorisnika, brojGodinaKorisnika)</li> <li>snake case: svaka rije\u010d je odvojena donjom crtom (ime_korisnika, broj_godina_korisnika)</li> </ul> <p>Tako\u0111er, imena varijabli su \"case-sensitive\" <pre><code>x = 1\nX = 2\n# x i X ce biti dvije razlicite varijable\n</code></pre></p>"},{"location":"content/intermediate/","title":"Napredni koncepti","text":""},{"location":"content/intermediate/#cilj","title":"Cilj","text":""},{"location":"content/intermediate/#uslovi","title":"Uslovi","text":"<p>Radno okru\u017eenje</p>"},{"location":"content/intermediate/#sadrzaj","title":"Sadr\u017eaj","text":""},{"location":"content/intermediate/#literatura-i-dodatni-materijali","title":"Literatura i dodatni materijali","text":"<p>Dodatni materijali</p>"},{"location":"content/intermediate/resources/","title":"Dodatni materijali i reference","text":""},{"location":"content/intermediate/setup/","title":"Pode\u0161avanje okru\u017eenja","text":""},{"location":"content/intermediate/setup/#instalacija-za-windows","title":"Instalacija za Windows","text":""},{"location":"content/intermediate/setup/#instalacija-python-310-za-windows","title":"Instalacija Python 3.10 za Windows:","text":"<ol> <li> <p>Posjetiti https://www.python.org/downloads/release/python-31011/ i na dnu stranice preuzeti preporu\u010deni instalacijski program za Python 3.10.11 za Windows (Napomena: izabrati 32-bitnu ili 64-bitnu arhitekturu prema potrebi; u ostalim koracima \u0107emo pretpostaviti da je izabrana 64-bitna verzija)</p> </li> <li> <p>Po preuzimanju, pokrenuti python-3.10.11-amd64.exe i ozna\u010diti opciju Add Python 3.10 to PATH i zatim kliknuti na Install now</p> </li> <li> <p>Testiranje instalacije:</p> </li> <li>Prona\u0107i program IDLE (Python 3.10 64-bit) i pokrenuti ga</li> <li>U IDLE konzoli unesite <code>print(\"Pozdrav!\")</code> i pritisnite ENTER</li> <li>Unesite <code>exit()</code> za zatvaranje IDLE Python konzole</li> <li>Otvori terminal</li> <li>Unesite <code>python</code> i pritisnite ENTER</li> <li>Unesite <code>print(\"Pozdrav!\")</code> i pritisnite ENTER</li> <li>Unesite <code>exit()</code> za izlazak iz Python-a</li> <li>Unesite <code>exit</code> i pritisnite ENTER za zatvaranje terminala</li> </ol>"},{"location":"content/intermediate/setup/#instalacija-visual-studio-code-vs-code-za-windows","title":"Instalacija Visual Studio Code (VS Code) za Windows:","text":"<ol> <li>Posjetiti https://code.visualstudio.com/download i preuzmite odgovaraju\u0107i instalacijski program za VS Code za Windows</li> <li>Pokrenite preuzeti fajl VSCodeUserSetup-x64-1.83.1.exe i pratite uputstva za instalaciju</li> </ol>"},{"location":"content/intermediate/setup/#instalacija-za-ubuntudebian","title":"Instalacija za Ubuntu/Debian","text":"<ul> <li>Python je ve\u0107 instaliran na ve\u0107ini Linux distribucija, bitno je da je instalirana bilo koja verzija Python 3</li> <li>Za instalaciju VS Code-a posjetite https://code.visualstudio.com/docs/setup/linux i pratite uputstva za instalaciju</li> </ul>"},{"location":"content/intermediate/Funkcije%20klasa/","title":"Funkcije klasa","text":"<p>Funkcije u klasama se nazivaju metode.</p> <p>Metode su funkcije definirane unutar klase koje  rade na podacima ili atributima klase.  Postoje uglavnom dvije vrste metoda:</p> <ul> <li>metode instance</li> <li>metode klase</li> </ul>"},{"location":"content/intermediate/Funkcije%20klasa/#metode-instance","title":"Metode instance","text":"<p>Metode instance su funkcije definirane unutar klase koje  rade na podacima specifi\u010dnim za instancu. One su naj\u010de\u0161\u0107i tip metoda u Python klasama.</p> <p>Da bi definirali metodu instance, morate uklju\u010diti self parametar kao prvi argument  u definiciji metode. self se odnosi na instancu same klase i omogu\u0107ava vam pristup i   izmjenu podataka specifi\u010dnih za instancu.</p> <p>Metode instance se obi\u010dno koriste za izvo\u0111enje radnji ili operacija koje uklju\u010duju atribute  (podatke) instance. Oni obuhvataju pona\u0161anje povezano s objektom.</p> <pre>\n<pre><code>class Pas:\n    def __init__(self, ime, starost):\n        self.ime = ime\n        self.starost = starost\n\n    def lajanje(self):\n        return f\"{self.ime} ka\u017ee av av!\"\n\n\npas1 = Pas(\"Rex\", 3)\n\n\nprint(dog1.lajanje()) \n</code></pre>\n</pre> <pre>\n<pre><code>    Output: Rex ka\u017ee av av\n</code></pre>\n</pre>"},{"location":"content/intermediate/Funkcije%20klasa/#metode-klase","title":"Metode klase","text":"<p>Metode klase su metode koje su vezane za klasu, a ne za instancu. Definirani su pomo\u0107u @classmethod dekoratora.</p> <p>Metode klase uzimaju samu klasu kao svoj prvi argument, obi\u010dno nazvan cls.  Ovo omogu\u0107ava metodama klase da pristupe i modifikuju podatke na nivou klase  (varijable klase).</p> <p>Metode klase se \u010desto koriste za operacije koje su povezane sa klasom kao cjelinom  i ne zavise od specifi\u010dnih podataka instance. Koriste se i za fabri\u010dke metode koje  kreiraju instance klase.</p> <pre>\n<pre><code>class Knjige:\n    broj_knjiga = 0  \n\n    def __init__(self, naslov, autor):\n        self.naslov = naslov\n        self.autor = autor\n        Knjige.broj_knjiga += 1\n\n    @classmethod\n    def prika\u017ei_broj_knjiga(cls):\n        return f\"Broj knjiga je: {cls.broj_knjiga}\"\n\n\nknjiga1 = Knjige(\"Harry Potter\", \"J.K.rowling\")\nknjiga2 = Knjige(\"Tvrdjava\", \"Mesa Selimovic\")\n\n\nprint(Knjige.prika\u017ei_broj_knjiga())  \n</code></pre>\n</pre> <pre>\n<pre><code>    Output: Broj knjiga je: 2\n</code></pre>\n</pre> <p>U Pythonu, pona\u0161anje public i private varijabli u metodama instance i klase je u skladu  s njihovim pravilima pristupa, koja su sljede\u0107a:</p> <ol> <li>Pubic varijabe:</li> </ol> <p>Javnim varijablama, koje nemaju prefiks,  mo\u017ee se pristupiti i mijenjati ih direktno unutar metoda instance i metoda klase.</p> <p><pre><code>&lt;/pre&gt;\n\n&lt;pre&gt;\n```python\nclass Klasa:\n    def __init__(self):\n        self.public_var = \"Ja sma public variabla\"\n\n    def instance_metoda(self):\n        return self.public_var\n\n    @classmethod\n    def metoda_klase(cls):\n        return cls().public_var\n\n\nobj = Klasa()\n\nprint(obj.instance_metoda())  \nprint(Klasa.metoda_klase())  \n</code></pre> </p> <pre>\n<pre><code>    Output: Ja sam public variabla\n            Ja sam public variabla\n</code></pre>\n</pre> <ol> <li>Private varijable:</li> </ol> <p>Privatne varijable, koje imaju prefiks dvostruke donje crte (npr. __private_var),  prolaze kroz mijenjanje imena u Pythonu kako bi bile manje dostupne izvan klase.</p> <p>Privatnim varijablama se i dalje mo\u017ee pristupiti i mijenjati ih unutar metoda instance,  ali morate koristiti iskrivljeno ime.</p> <p>Metode klase tako\u0111er mogu pristupiti privatnim varijablama koriste\u0107i iskrivljeno ime,  sve dok imaju pristup instanci klase.</p> <pre>\n<pre><code>class Klasa:\n    def __init__(self):\n        self.__private_var = \"Ja sam privatna variabla\"\n\n    def instance_metoda(self):\n        return self.__private_var\n\n    @classmethod\n    def metoda_klase(cls):\n        return cls().__private_var  \n\n\nobj = Klasa()\n\nprint(obj.instance_metoda())  \nprint(Klasa.metoda_klase()) \n</code></pre>\n</pre> <pre>\n<pre><code>    Output: Ja sam privatna variabla\n            Ja sam privatna variabla\n</code></pre>\n</pre> <p>U gornjem primjeru, privatna varijabla __private_var dostupna je i iz metode instance i  iz metode klase, ali u slu\u010daju metode klase koristimo iskrivljeno ime cls().__private_var  da joj pristupimo.</p> <p>Va\u017eno je napomenuti da iako mo\u017eete tehni\u010dki pristupiti privatnim varijablama izvan klase  koriste\u0107i iskrivljeno ime, to je protiv principa enkapsulacije i op\u0107enito se ne preporu\u010duje.  Privatne varijable su namijenjene da budu privatne s razlogom, a direktan pristup izvan  klase treba izbjegavati kad god je to mogu\u0107e kako bi se odr\u017eala \u010dista i robusna struktura  koda. Umjesto toga, trebali biste osigurati javne metode (getter i setter metode) za pristup  ili modificiranje privatnih podataka kada je to potrebno.</p>"},{"location":"content/intermediate/Klase/","title":"Klase","text":""},{"location":"content/intermediate/Klase/#objekti","title":"Objekti","text":"<p>Osnovni koncept OOP-a je objedinjavanje podataka(\u010dlanova) i funkcija(metoda) koje manipuliraju podacima  u jednu cijelinu koja se naziva objekat.</p> <p>Program se sastoji od skupa objekata koji me\u0111usobnom komunikacijaom rije\u0161avaju konkretni problem.</p> <p>Objekti se opisuju preko tri karakteristike:</p> <ul> <li>Identitet - svaki objekat ima svoj identifikator i mo\u017ee se razlikovati od svhih ostalih  objekata. Ime ili identitet svakog objekta mora biti jedinsven i razli\u010dit od drugih.</li> <li>Atributi - odnosi se na svojstva objekta. Na primjer, vrijednosti varijabli u  objektu sadr\u017ee podatke koji se mogu dodati, promijeniti ili izbrisati.</li> <li>Pona\u0161anje - radnje koje objekt mo\u017ee preduzeti. Na primjer, jedan  objekt mo\u017ee odgovoriti na drugi objekt da izvr\u0161i neke funkcije.</li> </ul>"},{"location":"content/intermediate/Klase/#klase","title":"Klase","text":"<p>Svaki objekat je instanca Klase.</p> <p>Klasa je specifikacija(ili \u0161ema) koje opisuje \u0161ta \u010de obijekat biti. Klase su fokus OOP-a. Na osnovu  jedne klase se moa\u017ee napraviti proizvoljan broj objekata sa  istim osobinama ili pona\u0161anjem.</p> <p>Klase efektivno defini\u0161u nove tipove podataka koji se onda mogu korisiti unutar programa za rije\u0161avanje korektnih problema.</p> <p>Klase se prave koriste\u0107i rije\u010d class i bloke koda, koji sadr\u017ei metode(funkcije).</p> <p>Primjer:</p> <pre>\n<pre><code>class Macka:\n  def __init__(self, boja, noge):\n    self.boja = boja\n    self.noge = noge\n\nfeliks = Macka(\"siva\", 4)\ngarflid = Macka(\"crna\", 4)\nmimi = Macka(\"smedja\", 3)\n</code></pre>\n</pre> <p>Atributima se mo\u017ee pristupiti na sljede\u0107i na\u010din</p> <pre>\n<pre><code>class Macka:\n  def __init__(self, boja, noge):\n    self.boja = boja\n    self.noge = noge\n\nfeliks = Macka(\"siva\", 4)\nprint(feliks.boja)\n</code></pre>\n</pre> <pre>\n<pre><code>Output: siva\n</code></pre>\n</pre>"},{"location":"content/intermediate/Konstruktori/","title":"Geteri, seteri i konstruktori","text":"<p>Metoda __init__ je najva\u017enija metoda u klasi. Ona se poziva kada se kreira instanca(objekt) klase, koriste\u0107i ime  klase kao funkciju. Metoda __init__ je konstruktor.</p> <p>Konstruktor je jedinstvena funkcija koja se automatski poziva kada se kreira objekt klase.  Glavna svrha konstruktora je da inicijalizira ili dodijeli vrijednosti \u010dlanovima   podataka te klase. Ne mo\u017ee vratiti nijednu vrijednost osim ni\u0161ta.</p> <p>Tipovi konstruktora:</p> <ul> <li>default konstruktor - jednostavan konstruktor koji ne prihvata nikakve argumente. Njegova  definicija ima samo jedan argument koji je referenca na instancu koja se konstrui\u0161e.</li> <li>parametrizovani konstruktor - uzima svoj prvi argument kao referencu na instancu koja se konstrui\u0161e poznatu kao self,  a ostale argumente daje programer.</li> </ul> <pre>\n<pre><code>class Macka:\n  #default konstruktor  \n  def __init__(self):\n    self.macka = \"Macke su super zivotinje\"\n\n    def print_Macka(self):\n        print(self.macka)\n\nobj = Macka()\nobj.print_Macka()\n</code></pre>\n</pre> <pre>\n<pre><code>Output: Macke su super zivotinje\n</code></pre>\n</pre> <pre>\n<pre><code>class Sabiranje:\n    prvi = 0\n    drugi = 0\n    suma = 0\n    def __init__(self, p, d):\n        self.prvi = p\n        self.drugi = s\n\n    def odgovor(self):\n        print(\"Prvi broj = \" + str(self.prvi))\n        print(\"Drugi broj = \" + str(self.drugi))\n        print(\"Suma dva broja = \" + str(self.suma))\n\n    def racun(self):\n        self.suma = self.prvi + self.drugi\n\nobj = Sabiranje(5, 3)\nobj = racun()\nobj = odgovor()\n</code></pre>\n</pre> <pre>\n<pre><code>Output: Prvi broj = 5\n        Drugi broj = 3\n        Suma dva broja = 8\n</code></pre>\n</pre> <p>Sve metode moraju imati self kao prvi parametar, iako nije eksplicitno proslije\u0111en,  Python dodaje argument self na listu umjesto vas; ne morate ga uklju\u010diti kada pozivate  metode. Unutar definicije metode, self se odnosi na instancu koja poziva metodu.</p> <p>Prednosti kori\u0161tenja konstruktora</p> <p>-Inicijalizacija objekata: Konstruktori se koriste  za inicijalizaciju objekata klase. Oni vam omogu\u0107avaju da   postavite zadane vrijednosti za atribute ili svojstva, a tako\u0111er  omogu\u0107avaju da inicijalizirate objekt s prilago\u0111enim podacima.</p> <p>-Jednostavan za implementaciju: Konstruktori se lako implementiraju u Python-u i  mogu se definirati kori\u0161tenjem metode init()</p> <p>-Bolja \u010ditljivost: Konstruktori pobolj\u0161avaju \u010ditljivost koda tako \u0161to jasno stavljaju do znanja koje vrijednosti se inicijaliziraju i kako se inicijaliziraju.</p> <p>-Enkapsulacija: Konstruktori se mogu koristiti za provo\u0111enje enkapsulacije, osiguravaju\u0107i  da su atributi objekta ispravno inicijalizirani i na kontroliran na\u010din.</p>"},{"location":"content/intermediate/Konstruktori/#getteri-i-setteri","title":"Getteri i setteri","text":"<p>Glavna svrha kori\u0161tenja gettera i settera u objektno orijentiranim programima je osigurati  enkapsulaciju podataka. Privatne varijable u Pythonu zapravo nisu skrivena polja kao u  drugim objektno orijentisanim jezicima. Getteri i Setteri u pythonu se \u010desto koriste kada:</p> <ul> <li>Koristimo gettere i settere da bismo dodali logiku validacije oko dobijanja i postavljanja vrednosti</li> <li>Da bi se izbjegao direktan pristup polju klase, tj. privatnim varijablama ne mo\u017ee se pristupiti direktno  ili modificirati od strane eksternog korisnika.</li> </ul> <pre>\n<pre><code>class Student:\n    def __init__(self, ocjena = 0):\n         self._ocjena = age\n\n    # getter\n    def get_ocjena(self):\n        return self._ocjena\n\n    # setter \n    def set_ocjena(self, x):\n        self._ocjena = x\n\nmujo = Student()\n\n\nmujo.set_ocjena(8)\n\n\nprint(mujo.get_ocjena())\n\nprint(mujo._ocjena)\n</code></pre>\n</pre> <pre>\n<pre><code>Output: 8\n        8\n</code></pre>\n</pre> <p>U gore navedene funkcije get_ocjena() i set_ocjena() pona\u0161aju se kao normalne funkcije i  ne igraju nikakav utjecaj kao getteri i setteri, da bi se postigla takva  funkcionalnost Python ima posebnu funkciju property().</p> <p>U Pythonu property() je ugra\u0111ena funkcija koja kreira i vra\u0107a objekt svojstva.  Objekt svojstva ima tri metode, getter(), setter() i delete(). property() funkcija  u Pythonu ima \u010detiri argumenta property(fget, fset, fdel, doc), fget je funkcija za   dohva\u0107anje vrijednosti atributa. fset je funkcija za postavljanje vrijednosti atributa.  fdel je funkcija za brisanje vrijednosti atributa. doc kreira docstring za atribut.   Objekat svojstva ima tri metode, getter(), setter() i delete() za navo\u0111enje fget,    fset i fdel pojedina\u010dno. Na primjer</p> <pre>\n<pre><code>class Student:\n    def __init__(self):\n        self._ocjena = 0\n\n\n    def get_ocjena(self):\n        print(\"getter metoda je pozvana\")\n        return self._ocjena\n\n\n    def set_ocjena(self, a):\n        print(\"setter metoda je pozvana\")\n        self._ocjena = a\n\n\n    def del_ocjena(self):\n        del self._ocjena\n\n    ocjena = property(get_ocjena, set_ocjena, del_ocjena)\n\nhaso = Student()\n\nhaso.ocjena = 9\n\nprint(haso.ocjena)\n</code></pre>\n</pre> <pre>\n<pre><code>Output: setter metoda je pozvana\n        getter metoda je pozvana\n        9\n</code></pre>\n</pre> <p>U prethodnoj metodi koristili smo funkciju property() da bismo postigli pona\u0161anje gettera  i settera. Me\u0111utim, getteri i setteri se tako\u0111er  koriste za provjeru valjanosti dobivanja i postavljanja vrijednosti atributa. Postoji jo\u0161   jedan na\u010din implementacije funkcije svojstva, tj. kori\u0161tenjem dekoratora. Python @property   je jedan od ugra\u0111enih dekoratora. Glavna svrha svakog dekoratora je da promijeni metode    ili atribute va\u0161e klase na takav na\u010din da korisnik va\u0161e klase nema potrebe da pravi bilo    kakvu promjenu u svom kodu. Na primjer</p> <pre>\n<pre><code>class Student:\n    def __init__(self):\n        self._ocjena = 0\n\n    @property\n    def ocjena(self):\n        print(\"getter metoda je pozvana\")\n        return self._ocjena\n\n\n    @age.setter\n    def ocjena(self, a):\n        if(a &lt; 6):\n            raise ValueError(\"Ocjena nije prolazna\")\n        print(\"setter metoda je pozvana\")\n        self._ocjena = a\n\nsuljo = Student()\n\nsuljo.ocjena = 7\n\nprint(suljo.ocjena)\n</code></pre>\n</pre> <pre>\n<pre><code>Output: setter metoda je pozvana\n        getter metoda je pozvana\n        7\n</code></pre>\n</pre> <p>U gornjem kodu je jasno kako koristiti @property dekorator za kreiranje gettera i  settera. Red 15-16 djeluje kao kod za provjeru valjanosti koji podi\u017ee  ValueError ako poku\u0161amo inicijalizirati ocjenu sa vrijedno\u0161\u0107u manjom od 6. Na ovaj na\u010din bilo   koja vrsta provjere valjanosti mo\u017ee se primijeniti u getter ili setter funkcijama.</p>"},{"location":"content/intermediate/apstraktne_klase/","title":"Apstraktne klase","text":"<p>Apstrakcija predstavlja proces izdvajanja zajedni\u010dkih karakteristika objekata i njihovo predstavljanje u obliku apstraktnih klasa. Apstraktna klasa predstavlja zajedni\u010dku nadklasu za sve konkretne klase koje imaju zajedni\u010dke karakteristike. Apstraktna klasa ne mo\u017ee imati instance, ve\u0107 se koristi za definisanje zajedni\u010dkih atributa i metoda koje \u0107e naslje\u0111ivati konkretne klase.</p> <p>Primjer: Trebamo realizovati klasu <code>GeometrijskiObjekat</code> u ravni. Postoje razli\u010dite vrste geometrijskih objekata, kao \u0161to su trougao, kvadrat, krug. Geometrijski objekti imaju metode poput obima i povr\u0161ine koje se defini\u0161u na razli\u010dite na\u010dine za razli\u010dite objekte. Potrebno je obavezati podklase da implementiraju ove metode.</p> <pre><code>from abc import ABC, abstractmethod\n\nclass GeometrijskiObjekat(ABC):\n    @abstractmethod\n    def obim(self):\n        pass\n\n    @abstractmethod\n    def povrsina(self):\n        pass\n\n\nclass Krug(GeometrijskiObjekat):\n    def __init__(self, r):\n        self.r = r\n\n    def obim(self):\n        return 2 * self.r * 3.14\n\n    def povrsina(self):\n        return self.r * self.r * 3.14\n\n    def __str__(self):\n        return \"Krug sa polupre\u010dnikom {}\".format(self.r)\n\n\nclass Kvadrat(GeometrijskiObjekat):\n    def __init__(self, a):\n        self.a = a\n\n    def obim(self):\n        return 4 * self.a\n\n    def povrsina(self):\n        return self.a * self.a\n\n    def __str__(self):\n        return \"Kvadrat sa stranicom {}\".format(self.a)\n</code></pre> <p>Apstraktne metode se defini\u0161u pomo\u0107u dekoratora <code>@abstractmethod</code>, a da bi se klasa ozna\u010dila kao apstraktna, potrebno je da naslje\u0111uje klasu <code>ABC</code> iz modula <code>abc</code> koji se uvozi na po\u010detku programa.</p>"},{"location":"content/intermediate/enkapsulacija/","title":"Enkapsulacija","text":"<p>Enkapsulacija je proces sakrivanja podataka i metoda unutar objekta kako bi se sprij\u010dilo njihovo nekontrolisano kori\u0161\u0107enje. Enkapsulacijom se mo\u017ee posti\u0107i bolja raspodjela funkcionalnosti me\u0111u klasama. Svaka klasa raspola\u017ee samo podacima koji su joj prirodno dodijeljeni \u0161to onemogu\u0107ava mije\u0161anje objekata jedne klase u funkcionalnosti objekata druge klase.</p> <p>Primjer:  Neka su date klase <code>Krug</code> i <code>Crtez</code>\u201a pri \u010demu se na crte\u017eu nacrtana dva kruga, prirodno je da <code>Krug</code> sadr\u017ei podatke koji ga opisuju (koordinate centra i polupre\u010dnik), a neka <code>Crtez</code> sadr\u017ei, kao atribute,  dva kruga. </p> <p>Objekat klase <code>Crtez</code> ne treba da ima direktan pristup podacima koji opisuju krug, ve\u0107 je potrebno da im pristupa ili manipuli\u0161e njima isklju\u010divo pozivanjem metoda nad objektima klase <code>Krug</code>, poput metode <code>transliraj</code> kojom se krug pomjera za dati vektor pomjeraja.   </p> <pre><code>class Krug:\n    def __init__(self, cx, cy, r):\n        self.cx = cx\n        self.cy = cy\n        self.r = r\n\n    def transliraj(self, dx, dy):\n        self.cx += dx\n        self.cy += dy\n\n    def __str__(self):\n        return \"Krug sa centrom u ta\u010dki ({},{}) i polupre\u010dnikom {}\".format(self.cx, self.cy, self.r)\n\nclass Crtez:\n    def __init__(self, krug1, krug2):\n        self.krug1 = krug1\n        self.krug2 = krug2\n\n    def transliraj_sve(self, dx, dy):\n        self.krug1.transliraj(dx, dy)\n        self.krug2.transliraj(dx, dy)\n\n    def prikazi(self):\n        print(self.krug1)\n        print(self.krug2)\n</code></pre> <p>Enkapsulacija nam sugeri\u0161e da se program (tj. problem) i njegovo stanje mogu podijeliti na manje dijelove ali da ujedno ti dijelovi budu dovoljno nezavisni, te da se mogu ponovo upotrebljavati, o ovome treba voditi ra\u010duna prilikom pisanja programa.</p>"},{"location":"content/intermediate/nasljedjivanje/","title":"Naslje\u0111ivanje","text":"<p>Naslje\u0111ivanje je jedan od najva\u017enijih koncepata u objektno orijentiranom programiranju. To je proces u kojem jedna klasa preuzima atribute i metode druge klase. Nova klasa se naziva podklasa ili dijete klasa, a klasa koja je naslije\u0111ena se naziva nadklasa ili bazna (osnovna) klasa. Podklasa naslje\u0111uje sve metode i atribute od nadklase, ali isto tako ima mogu\u0107nost da defini\u0161e nove atribute i metode ili da predefini\u0161e postoje\u0107e.</p> <p>Za\u0161to je ovo korisno? Zato jer nam omogu\u0107ava da kreiramo nove klase koje su bazirane na postoje\u0107im klasama. Na taj na\u010din mo\u017eemo iskoristiti atribute i metode postoje\u0107e klase bez da ih moramo ponovo pisati. Ovo nam omogu\u0107ava da br\u017ee i lak\u0161e kreiramo nove klase koje imaju sli\u010dne atribute i metode kao postoje\u0107e klase.</p> <p>Primjer 1:</p> <pre><code>class Zivotinja:\n    def __init__(self, ime):\n        self.ime = ime\n\n    def oglasavanje(self):\n        pass\n\nclass Pas(Zivotinja):\n    def __init__(self, ime):\n        super().__init__(ime)\n\n    def oglasavanje(self):\n        return \"vau vau\"\n\nclass Macka(Zivotinja):\n    def __init__(self, ime):\n        super().__init__(ime)\n\n    def oglasavanje(self):\n        return \"mijau mijau\"\n</code></pre> <p>U ovom primjeru, klasa <code>Zivotinja</code> je nadklasa koja sadr\u017ei konstruktor i metodu <code>oglasavanje</code>. Klase <code>Pas</code> i <code>Macka</code> su podklase koje naslje\u0111uju konstruktor i metodu <code>oglasavanje</code> od klase <code>Zivotinja</code>. Svaka podklasa ima svoj konstruktor koji poziva konstruktor nadklase i proslje\u0111uje mu ime \u017eivotinje. Metoda <code>oglasavanje</code> je predefinirana u svakoj podklasi na odgovaraju\u0107i na\u010din.</p> <p>Kada se pozove metoda <code>oglasavanje</code> za objekt tipa <code>Pas</code>, Python \u0107e prvo tra\u017eiti metodu <code>oglasavanje</code> u klasi <code>Pas</code>. Ako je ne prona\u0111e, tra\u017eit \u0107e je u klasi <code>Zivotinja</code> (nadklasa). Ako je ne prona\u0111e ni tamo, tra\u017ei\u0107e je u svim ostalim nadklasama. Ako je ne prona\u0111e nigdje, Python \u0107e vratiti gre\u0161ku. </p> <p>Funkcija <code>super()</code> je specijalna funkcija koja nam omogu\u0107ava pozivanje metoda nadklase. U primjeru iznad, funkcija <code>super()</code> se koristi u konstruktoru podklase kako bi se pozvao konstruktor nadklase.</p> <p>Va\u017eno je napomenuti da nadklasa mora biti definirana prije podklase.</p>"},{"location":"content/intermediate/nasljedjivanje/#polimorfizam","title":"Polimorfizam","text":"<p>Polimorfizam je sposobnost objekta da se pona\u0161a na vi\u0161e na\u010dina. Naziv polimorfizam dolazi od gr\u010dkih rije\u010di poly (mnogo) i morphe (oblik). </p> <p>U prethodnom primjeru smo vidjeli da klase <code>Pas</code> i <code>Macka</code> naslje\u0111uju klasu <code>Zivotinja</code> i implementiraju metodu <code>oglasavanje</code>. Obje metode imaju isti naziv, ali se razlikuju po tome \u0161to vra\u0107aju razli\u010dite vrijednosti. Ovo je primjer polimorfizma - koristili smo isto ime metode ali razli\u010dite implementacije.</p> <p>Napomena: Polimorfizam postoji i bez OOP-a.</p> <pre><code>def sabiranje(a, b):\n    return a + b\n\nprint(sabiranje(2, 3))\n\nprint(sabiranje(\"2\", \"3\"))\n</code></pre> <p>Ova funkcija ima isto ime, ali se pona\u0161a na razli\u010dite na\u010dine u zavisnosti od tipova argumenata. Ovo je tako\u0111e primjer polimorfizma.</p> <p>Primjer 2:</p> <pre><code>class Automobil:\n    def __init__(self, marka, model, godina):\n        self.marka = marka\n        self.model = model\n        self.godina = godina\n        self.kilometraza = 0\n\n    def opis(self):\n        opis = f\"{self.marka} {self.model} {self.godina}\"\n        return opis.title()\n\n    def get_kilometraza(self):\n        return self.kilometraza\n\n    def set_kilometraza(self, kilometraza):\n        if kilometraza &gt;= self.kilometraza:\n            self.kilometraza = kilometraza\n        else:\n            print(\"Ne mo\u017eete smanjiti kilometra\u017eu automobila.\")\n\nclass Baterija:\n    def __init__(self, kapacitet_baterije=40):\n        self.kapacitet_baterije = kapacitet_baterije\n\n    def opis_baterije(self):\n        return f\"Ovaj automobil ima bateriju kapaciteta {self.kapacitet_baterije}kWh.\"\n\n    def get_domet(self):\n        if self.kapacitet_baterije == 40:\n            domet = 270\n        elif self.kapacitet_baterije == 60:\n            domet = 380\n        elif self.kapacitet_baterije == 135:\n            domet = 510\n\n        print(f\"Domet je {domet} kilometara.\")\n\nclass ElektricniAutomobil(Automobil):\n    def __init__(self, marka, model, godina, kapacitet_baterije=40):\n        super().__init__(marka, model, godina)\n        self.baterija = Baterija(kapacitet_baterije)\n\n    def opis(self):\n        opis = f\"{self.marka} {self.model} {self.godina}\"\n        return opis.title()\n\n    def get_bat_kapacitet(self):\n        return self.baterija.opis_baterije()\n\n    def get_domet(self):\n        return self.baterija.get_domet()\n\n\ntesla_m3 = ElektricniAutomobil(\"Tesla\", \"Model 3\", 2022, 60)\nprint(tesla_m3.opis())\nprint(tesla_m3.get_bat_kapacitet())\ntesla_m3.get_domet()\n\nrivian_1s = ElektricniAutomobil(\"Rivian\", \"R1S\", 2023, 135)\nprint(rivian_1s.opis())\nprint(rivian_1s.get_bat_kapacitet())\nrivian_1s.get_domet()\n</code></pre> <p>U ovom primjeru smo modelovali elektri\u010dni automobil. Klasu <code>ElektricniAutomobil</code> smo definisali kao podklasu klase <code>Automobil</code>, a definisali smo i pomo\u0107nu klasu <code>Baterija</code> koja predstavlja atribut klase <code>ElektricniAutomobil</code>. </p>"},{"location":"content/intermediate/ponavljanje/","title":"Ponavljanje","text":""}]}